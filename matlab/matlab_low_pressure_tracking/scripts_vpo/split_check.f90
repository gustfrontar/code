PROGRAM SPLIT_CHECK

!==========================================================================
! THIS PROGRAM WILL READ 3 FILES CORRESPONDING TO CONSECUTIVE TIMES
! THE FILES WILL CONTAIN INFORMATION ABOUT THE MINIMUN LOCATION AND SHAPE.
! THE PROGRAM WILL CHECK FOR SYSTEMS THAT SPLIT FOR ONE TIME BUT ARE PART
! OF THE SAME SYSTEM IN THE PREVIOUS AND IN THE FOLLOWING TIMES
!==========================================================================
IMPLICIT NONE
!=============================================
!GRID CHARACTERISTICS
!=============================================
PUBLIC
INTEGER  :: nx!Grid dimensions. 
INTEGER  :: ny!Grid dimensions.
INTEGER  :: nf!Additional data dimension.

!==============================================
!OTHER VARIABLE DECLARATIONS
!==============================================
!VARIABLES FOR INPUT DATA
!VARIABLES FOR FINDING MINIMUNS AND ITS ASSOCIATED SYSTEMS
INTEGER,ALLOCATABLE  ::  MIN_I(:,:),MIN_J(:,:)
REAL, ALLOCATABLE    ::  MINLAT(:,:),MINLON(:,:),MINLATINT(:,:),MINLONINT(:,:)
REAL, ALLOCATABLE    ::  MINLATCENT(:,:),MINLONCENT(:,:)   !Latitude and longitud of system centroid.
INTEGER, ALLOCATABLE ::  MIN_GRID_SIZE(:,:)  !System size in number of grid points.
INTEGER, ALLOCATABLE ::  MIN_INDEX(:,:,:)    !List of grid points (columnwise index) that are part of a system.
REAL,ALLOCATABLE     ::  MIN_AREA(:,:)       !System area (in sq kilometers).
REAL,ALLOCATABLE     ::  MEAN_ANOM_SIS(:,:)  !System mean anomaly.
REAL,ALLOCATABLE     ::  MIN_ANOM_SIS(:,:)   !System min anomaly.
INTEGER              ::  NMINIMOS(3),MAXNMINIMOS
INTEGER,ALLOCATABLE  ::  MIN_ID(:,:)

REAL,ALLOCATABLE     ::  MIN_ADDITIONAL_DATA(:,:,:) !Minimun additional data over each system 
REAL,ALLOCATABLE     ::  MAX_ADDITIONAL_DATA(:,:,:) !Maximun additional data over each system
REAL,ALLOCATABLE     ::  MEAN_ADDITIONAL_DATA(:,:,:)!Mean additional data over each system.

REAL                 ::  UMB_SUPERPOSITION=0.6      !If superpostion is greater than this I will say that
                                                    !there is a macht between two systems.
INTEGER,ALLOCATABLE  ::  SYSTEM_MATCH_ID(:,:)       !Array to store the systems that match any system of the current time.
REAL                 ::  TMPPERCENTAJE
!READ THE DATA

CALL READ_DATA

!I WILL DO A LOOP OVER ALL THE SYSTEMS OF CURRENT TIME (SUB=2)
!FOR EACH SYSTEM I WILL COMPARE IT WITH ALL THE SYSTEM IN THE PREVIOUS TIME (SUB=1) AND IN THE
!NEXT TIME (SUB=3).

ALLOCATE(SYSTEM_MATCH_ID(3,NMINIMOS(2)))
SYSTEM_MATCH_ID=0

DO TT=1,3,2
DO JJ=1,NMINIMOS(2)
  DO KK=1,NMINIMOS(TT)
     CALL COMPARE_SYSTEMS(MIN_INDEX(2,JJ,:),MIN_INDEX(TT,KK,:),   & 
     &                    MIN_GRID_SIZE(2,JJ),MIN_GRID_SIZE(TT,KK),TMPPERCENTAJE) 
     IF(TMPPERCENTAJE .GT. UMB_SUPERPOSITION)THEN
       SYSTEM_MATCH_ID(JJ,TT)=KK  !THE SYSTEM JJ, IS ASSOCIATED WITH SYSTEM KK AT TIME TT
     ENDIF
  ENDDO
ENDDO
ENDDO





STOP

!===========================================================================
SUBROUTINE READ_DATA()
!This subrutine will read the data, the corresponding climatology and any 
!additional data. 
IMPLICIT NONE
CHARACTER*20  :: FILE1='previous.bin',FILE2='current.bin',FILE3='next.bin'
INTEGER       :: ii,i,j
REAL          :: TMP

      !FIRST GET THE MAXIMUN NUMBER OF MINIMUNS.
      OPEN(UNIT=21,FILE=FILE1,FORM='UNFORMATTED',ACCESS='SEQUENTIAL',STATUS='UNKNOWN')
      READ(21)TMP 
      NX=AINT(TMP) !GET NX
      READ(21)TMP
      NY=AINT(TMP) !GET NY
      READ(21)TMP
      NF=AINT(TMP) !GET NF   I WILL ASSUME THAT THIS 3 VALUES ARE THE SAME FOR THE THREE FILES
      READ(21)TMP
      NMINIMOS(1)=AINT(TMP)
      CLOSE(21)
      OPEN(UNIT=21,FILE=FILE2,FORM='UNFORMATTED',ACCESS='SEQUENTIAL',STATUS='UNKNOWN')
      DO ii=1:4
         READ(21)TMP
      ENDDO
      NMINIMOS(2)=AINT(TMP)
      CLOSE(21)
      OPEN(UNIT=21,FILE=FILE3,FORM='UNFORMATTED',ACCESS='SEQUENTIAL',STATUS='UNKNOWN')
      DO ii=1:4
         READ(21)TMP
      ENDDO
      NMINIMOS(3)=AINT(TMP)
      CLOSE(21)
      MAXNMINIMOS=MAXVAL(NMINIMOS)   

      ALLOCATE(MINLON(3,MAXNMINIMOS),MINLAT(3,MAXNMINIMOS))
      ALLOCATE(MINLONINT(3,MAXNMINIMOS),MINLONINT(3,MAXNMINIMOS))
      ALLOCATE(MINLONCENT(3,MAXNMINIMOS),MINLONCENT(3,MAXNMINIMOS))
      ALLOCATE(MIN_I(3,MAXNMINIMOS),MIN_J(3,MAXNMINIMOS))
      ALLOCATE(MIN_ID(3,MAXNMINIMOS))
      ALLOCATE(MIN_AREA(3,MAXNMINIMOS))
      ALLOCATE(MIN_ANOM_SIS(3,MAXNMINIMOS),MEAN_ANOM_SIS(3,MAXNMINIMOS))
      ALLOCATE(MIN_ADDITIONAL_DATA(3,MAXNMINIMOS,NF))
      ALLOCATE(MAX_ADDITIONAL_DATA(3,MAXNMINIMOS,NF))
      ALLOCATE(MEAN_ADDITIONAL_DATA(3,MAXNMINIMOS,NF))
      ALLOCATE(MIN_GRID_SIZE(3,MAXNMINIMOS))
      ALLOCATE(MIN_INDEX(3,MAXNMINIMOS,10*nx))


      CALL READ_FILE(FILE1,1)
      CALL READ_FILE(FILE2,2)
      CALL READ_FILE(FILE3,3)

RETURN
END SUBROUTINE READ_DATA

!===========================================================================
SUBROUTINE READ_FILE(FILENAME,SUB)
!This subroutine reads a minimun file and puts the data in the corresponding
!possition of the minimun array.(1-previous, 2-current and 3-next)
IMPLICIT NONE
CHARACTER*20  :: FILENAME
REAL          :: TMP,TMP(MAXNMINIMOS),TMP2(10*NX)
INTEGER       :: SUB
INTEGER       :: ii,i,j,FLAG,jj

OPEN(UNIT=71,FILE=FILENAME,FORM='UNFORMATTED',ACCESS='SEQUENTIAL',STATUS='UNKNOWN')

!FIRST READ OUT GRID DIMENSIONS
DO ii=1,4
READ(71) !SKIP THE FIRST 3 RECORDS.
ENDDO
!READ THE  FLAG FOR THE PRESENCE OF ADDITIONAL DATA (1 IF PRESENT, 0 IF NOT PRESENT)
READ(71)TMP
FLAG=AINT(TMP)
!READ SYSTEM LONGITUDES AND LATITUDES.
READ(71)(MINLON(ii,SUB),ii=1,NMINIMOS(SUB))
READ(71)(MINLAT(ii,SUB),ii=1,NMINIMOS(SUB))
READ(71)(MINLONINT(ii,SUB),ii=1,NMINIMOS(SUB))
READ(71)(MINLATINT(ii,SUB),ii=1,NMINIMOS(SUB))
READ(71)(MINLONCENT(ii,SUB),ii=1,NMINIMOS(SUB))
READ(71)(MINLATCENT(ii,SUB),ii=1,NMINIMOS(SUB))
!READ SUBINDICES CORRESPONDING TO MINIMUN POSSITION
READ(71)(TMP(ii),ii=1,NMINIMOS(SUB))
MIN_I(SUB,:)=AINT(TMP)
READ(71)(TMP(ii),ii=1,NMINIMOS(SUB))
MIN_J(SUB,:)=AINT(TMP)
!READ SYSTEM ID
READ(71)(TMP(ii),ii=1,NMINIMOS(SUB))
MIN_ID(SUB,:)=AINT(TMP)
!READ SYSTEM AREA
READ(71)(TMP(ii),ii=1,NMINIMOS(SUB))
MIN_AREA(SUB,:)=AINT(TMP)

!READ MINIMUN/MEAN
WRITE(71)(MIN_ANOM_SIS(ii),ii=1,NMINIMOS(SUB))
WRITE(71)(MEAN_ANOM_SIS(ii),ii=1,NMINIMOS(SUB))
!IF IS PRESENT READ ADDITIONAL DATA
IF(FLAG .EQ. 1)THEN
DO JJ=1,nf
   WRITE(71)(MIN_ADDITIONAL_DATA(ii),ii=1,NMINIMOS(SUB))
   WRITE(71)(MAX_ADDITIONAL_DATA(ii),ii=1,NMINIMOS(SUB))
   WRITE(71)(MEAN_ADDITIONAL_DATA(ii),ii=1,NMINIMOS(SUB))
ENDDO
ENDIF
!NOW I WILL READ THE SUBINDICES CORRESPONDING TO EACH SYSTEM.
!FIRST THE NUMBER OF GRID POINTS CORRESPONDING TO EACH SYSTEM
WRITE(71)(TMP(ii),ii=1,NMINIMOS(SUB))
MIN_GRID_SIZE(SUB,:)=AINT(TMP)
!THEN THE LIST OF SUBINDICES FOR EACH SYSTEM
DO II=1,NMINIMOS
   READ(71)(TMP2(ii),ii=1,MIN_GRID_SIZE(SUB,II))
   MIN_INDEX(SUB,II,:)=AINT(TMP2)
ENDDO

CLOSE(71)

RETURN
END SUBROUTINE READ_FILE

!==========================================================================================
SUBROUTINE COMPARE_SYSTEM(SISA,SISB,NSISA,NSISB,PERCENTAJE)
IMPLICIT NONE
INTEGER  :: SISA(NX*10),NSISB(NX*10)   !INDEX LIST FOR SYSTEM A AND B
INTEGER  :: NSISA,NSISB                !LIST SIZE FOR SYSTEM A AND B
INTEGER  :: COUNTER,II
!THIS SUBROUTINE WILL TEST THE PERCENTAGE OF SYSTEM A WHICH COINCIDES WITH THE POSITION 
!OF SYSTEM B.
COUNTER=0
DO II=1,NSISA
     
     IF( COUNT(SISB(1:NSISB) .EQ. SISA(II) ) > 0 )THEN
     COUNTER=COUNTER+1  !THE POINT II OF SYSTEM A COINCIDES WITH SOME POINT OF SYSTEM B.
     ENDIF
ENDDO
PERCENTAJE=COUNTER/NSISA
RETURN
END SUBROUTINE COMPARE_SYSTEM    

!===========================================================================================

SUBROUTINE DISTLL(alon,alat,blon,blat,dist)
IMPLICIT NONE
REAL  :: alon,alat,blon,blat,pi,re,lon1,lon2,lat1,lat2
REAL  :: cosd,dist

pi=ACOS(-1.)
re=6371.3e3

    lon1 = alon * pi /180
    lon2 = blon * pi /180
    lat1 = alat * pi /180
    lat2 = blat * pi /180

    cosd = SIN(lat1)*SIN(lat2) + COS(lat1)*COS(lat2)*COS(lon2-lon1)
    cosd = MIN(1.0,cosd)
    cosd = MAX(-1.0,cosd)

    dist = ACOS( cosd ) * re

RETURN
END SUBROUTINE DISTLL


END PROGRAM  SPLIT_CHECK
